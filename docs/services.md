# Services
Services are responsible for the business logic of the applications. It provides an interface for any code to interact with the data and processes of the service.

## Contents
* [Repositories](#repositories)
* [Resolvers](#resolvers)
* [Input](#input)
* [Output](#output)

## Repositories
If a service makes use of a data model such as a User service, then any data peristing shoud be done through a repository. To add a [repository](repositories.md) to a service class you need to inject the repository in the constructor as a dependency.
```
@Injectable()
export class UserService {

  constructor(
    @InjectRepository(UserRepository) // Registers the repo
    private readonly userRepository: UserRepository,
  ) {}
}
```
Now that we have registered the repository in the service, we need to provide it in the module so that the IOC container has a registered instance to provide.
```
@Module({
    imports: [TypeOrmModule.forFeature([User, UserRepository])], // Informs the IOC Container how to provide the user repository
    controllers: [UserController],
    providers: [
        UserService,
    ],
    exports: [
        UserService,
    ],
})
export class UserModule {}
```

This the `@InjectRepository` parameter decorator checks the IOC container for the `'UserRepositoryRepository'` [injection token](dependency-injection.md#injection-token) and will instatiate the dependency if it has been registered in the container.

## Resolvers
As the name suggests, [Resolvers](https://docs.nestjs.com/graphql/resolvers-map) are used to resolve GraphQL queries into the desired data.  This is done with the help of the ORM library [SequelizeJS](http://docs.sequelizejs.com/) and a custom ["sequelize-resolver"](../src/graphql/resolvers/sequelize-resolver.ts) class that is used to create SQL statements based on the input parameters.

Use `sequelize-resolver` in your `@Resolver` annotated classes in order to resolve entities as well as relationships for related entities.  For example, in order to resolve the `Users` for a `Company`, the sequelize-resolver "resolveRelationships()" function is used:

```
@ResolveProperty()
  async users(@Parent() company, @Args() args, @Context() context, @Info() info): Promise<Model<User>[]>{
    const usersForCompany: Model<User>[] = await this.sequelizeResolver.resolveRelationships(company, User, 'users', args, context, info);
    return usersForCompany;
  }
```

There are currently four "resolve*" functions in `sequelize-resolver` which have slightly differing purposes (Note: See the function definitions themselves for more information about input parameters):
1. **resolve()** - Resolves a GraphQL query for a single object. It builds the sequelize query based on the queried fields, executes the query, and returns the results.
2. **resolveMany()** - Resolves a GraphQL query for a list of multiple objects. It builds the sequelize query based on the queried fields, executes the query, and returns the resulting list.
3. **resolvePaginated()** - Resolves a GraphQL query for a paginated list. It builds the sequelize query based on the queried fields, executes the query, and returns the results. It returns the data along with pagination information for subsequent queries.
4. **resolveRelationships()** - Resolves related entities for a given Parent. It takes the Parent instance and the desired relationship passed in as parameters to determine which sequelize autogenerated Getter function to execute. Returns either a single entity or a list.

For more information regarding custom field resolvers, see [this document](../src/graphql/resolvers/field-resolvers.md)



## Input
We try to use type-hinting wherever possible. If a method is meant to be used with a controller, make sure to typehint input with the corresponding [DTO](validation.md#assigning-validation-to-a-route)
```
/**
* Uses DTO for typehint
*/
async create(userData: CreateUserDto): Promise<UserRO> {
    const user = this.userRepository.create(userData); // Only creates an object
    return await this.userRepository.save(user); // Persists the object
  }
```
## Output
Make sure to typehint the return value for service methods too using a Return Object interface to decribe the  expected data structure. In the example above you will see the create method returns a promise containing a `UserRO`.
